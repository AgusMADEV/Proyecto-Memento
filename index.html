<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <title>Memento ‚Äî Red 3D Interactiva</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <style>
      body,html{
        margin:0;
        padding:0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        overflow:hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* ===== ANIMACIONES CSS ===== */
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes slideIn {
        from {
          transform: translateX(-20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideInDown {
        from {
          transform: translateY(-30px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes pulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* ===== FROSTED GLASS - Panel de Control macOS Style ===== */
      #controles{
        position:fixed;
        top:20px;
        left:20px;
        width: 340px;
        padding:0;
        
        /* Efecto frosted glass macOS */
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        
        border: 0.5px solid rgba(255, 255, 255, 0.18);
        border-radius: 16px;
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.12),
          0 2px 8px rgba(0, 0, 0, 0.08),
          inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        
        font-size:13px;
        z-index:10;
        max-height:90vh;
        overflow:hidden;
        color:#ffffff;
        display: flex;
        flex-direction: column;
        
        /* Animaci√≥n de entrada */
        animation: slideIn 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      }

      /* Header del Dashboard - Frosted Style */
      .dashboard-header {
        padding: 24px;
        background: rgba(255, 255, 255, 0.03);
        border-bottom: 0.5px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px 16px 0 0;
        position: relative;
      }

      .dashboard-title {
        font-size: 17px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.95);
        margin: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        letter-spacing: -0.3px;
      }

      .dashboard-title span:first-child {
        font-size: 20px;
        opacity: 0.9;
      }

      .dashboard-subtitle {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.45);
        margin: 4px 0 0 0;
        font-weight: 400;
        letter-spacing: 0;
      }

      /* Contenido con scroll */
      .dashboard-content {
        overflow-y: auto;
        overflow-x: hidden;
        max-height: calc(90vh - 88px);
        padding: 20px;
        flex: 1;
      }

      .dashboard-content::-webkit-scrollbar {
        width: 8px;
      }

      .dashboard-content::-webkit-scrollbar-track {
        background: transparent;
        margin: 4px;
      }

      .dashboard-content::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }

      .dashboard-content::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
        background-clip: padding-box;
      }

      /* Secciones colapsables - Frosted Style */
      .control-section {
        margin-bottom: 8px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        border: 0.5px solid rgba(255, 255, 255, 0.08);
        overflow: hidden;
        transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .control-section:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.15);
      }

      .section-header {
        padding: 12px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        user-select: none;
        transition: all 0.2s ease;
        position: relative;
      }

      .section-header:active {
        opacity: 0.7;
      }

      .section-title {
        font-size: 13px;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.9);
        display: flex;
        align-items: center;
        gap: 8px;
        letter-spacing: -0.1px;
      }

      .section-title .prop-counter {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 20px;
        height: 18px;
        padding: 0 6px;
        margin-left: 4px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 9px;
        font-size: 10px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.8);
        border: 0.5px solid rgba(255, 255, 255, 0.15);
        letter-spacing: 0;
      }

      .section-icon {
        font-size: 15px;
        opacity: 0.8;
        transition: transform 0.25s ease;
      }

      .section-header:hover .section-icon {
        transform: scale(1.08);
        opacity: 1;
      }

      .section-toggle {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.4);
        transition: transform 0.25s cubic-bezier(0.16, 1, 0.3, 1), color 0.2s ease;
      }

      .section-header:hover .section-toggle {
        color: rgba(255, 255, 255, 0.6);
      }

      .control-section.collapsed .section-toggle {
        transform: rotate(-90deg);
      }

      .section-content {
        padding: 0 16px 12px 16px;
        display: block;
        animation: expandSection 0.25s ease-out;
        max-height: 2000px;
        transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.25s ease-out;
        opacity: 1;
        overflow: visible;
      }

      .control-section.collapsed .section-content {
        max-height: 0;
        padding: 0 16px;
        opacity: 0;
        overflow: hidden;
      }

      @keyframes expandSection {
        from {
          opacity: 0;
          transform: translateY(-5px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Controles de input - Frosted Style */
      .control-group {
        margin-bottom: 16px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.65);
        font-weight: 500;
      }

      .control-value {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 42px;
        height: 22px;
        padding: 0 10px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 6px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.95);
        font-size: 11px;
        border: 0.5px solid rgba(255, 255, 255, 0.15);
        letter-spacing: 0.3px;
        font-variant-numeric: tabular-nums;
      }

      #controles input[type=range]{
        width:100%;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      #controles input[type=range]:hover {
        opacity: 1;
      }

      #controles input[type=range]:focus {
        outline: none;
      }

      /* Checkbox - Frosted Style */
      .checkbox-group {
        display: flex;
        align-items: center;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 8px;
        margin-bottom: 8px;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        cursor: pointer;
        border: 0.5px solid rgba(255, 255, 255, 0.06);
      }

      .checkbox-group:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.1);
      }

      .checkbox-group input[type=checkbox] {
        width: 16px;
        height: 16px;
        margin-right: 10px;
        cursor: pointer;
        accent-color: rgba(255, 255, 255, 0.9);
      }

      .checkbox-group label {
        flex: 1;
        cursor: pointer;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.75);
        font-weight: 500;
        transition: color 0.2s ease;
      }

      .checkbox-group:hover label {
        color: rgba(255, 255, 255, 0.9);
      }

      /* Propiedades din√°micas - Frosted Style */
      #propiedades {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0;
      }

      #propiedades .bloque-prop{
        padding: 10px 0;
        margin-bottom: 10px;
        animation: slideInDown 0.4s ease-out;
        border-bottom: 0.5px solid rgba(255, 255, 255, 0.06);
      }

      #propiedades .bloque-prop:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }

      #propiedades .titulo-prop{
        font-weight: 600;
        margin-bottom: 8px;
        color: rgba(255, 255, 255, 0.6);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }

      #propiedades label{
        display: inline-flex;
        align-items: center;
        padding: 6px 10px;
        margin: 0 6px 6px 0;
        background: rgba(255, 255, 255, 0.08);
        border: 0.5px solid rgba(255, 255, 255, 0.12);
        border-radius: 6px;
        font-size: 11px;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        cursor: pointer;
        white-space: nowrap;
      }

      #propiedades label:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
      }

      #propiedades input[type=checkbox] {
        margin-right: 6px;
        accent-color: rgba(255, 255, 255, 0.9);
        flex-shrink: 0;
      }

      /* Ayuda de teclas - Frosted Style */
      #ayudaTeclas{
        font-size: 11px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 8px;
        border: 0.5px solid rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.6);
        line-height: 1.7;
        animation: fadeIn 1s ease-out;
      }

      #ayudaTeclas strong {
        color: rgba(255, 255, 255, 0.8);
        font-size: 11px;
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
      }

      /* ===== FROSTED GLASS - Modal 2D ===== */
      #modalOverlay{
        position:fixed;
        top:0;
        left:0;
        width:100vw;
        height:100vh;
        background:rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        display:none;
        align-items:center;
        justify-content:center;
        z-index:20;
        animation: fadeIn 0.25s ease-out;
      }

      #modalCaja{
        /* Efecto frosted glass */
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        
        border: 0.5px solid rgba(255, 255, 255, 0.18);
        border-radius: 16px;
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.12),
          0 2px 8px rgba(0, 0, 0, 0.08),
          inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        
        max-width:600px;
        max-height:80vh;
        width:90%;
        color:rgba(255, 255, 255, 0.95);
        display:flex;
        flex-direction:column;
        
        /* Animaci√≥n de entrada */
        animation: scaleIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }

      #modalHeader{
        padding:16px 20px;
        border-bottom:0.5px solid rgba(255, 255, 255, 0.12);
        display:flex;
        justify-content:space-between;
        align-items:center;
        font-size:15px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 16px 16px 0 0;
      }

      #modalTitulo{
        font-weight:600;
        font-size: 16px;
        color: rgba(255, 255, 255, 0.95);
        letter-spacing: -0.2px;
      }

      #modalCerrar{
        cursor:pointer;
        padding:6px 12px;
        border-radius:6px;
        border:0.5px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.08);
        font-size:12px;
        color: rgba(255, 255, 255, 0.8);
        font-weight: 500;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      }

      #modalCerrar:hover{
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.2);
        transform: scale(1.02);
      }

      #modalCerrar:active{
        transform: scale(0.98);
        opacity: 0.8;
      }

      #modalContenido{
        padding:20px;
        overflow:auto;
        font-size:14px;
        line-height:1.6;
        animation: fadeIn 0.4s ease-out 0.1s backwards;
      }

      #modalContenido::-webkit-scrollbar {
        width: 8px;
      }

      #modalContenido::-webkit-scrollbar-track {
        background: transparent;
        margin: 4px;
      }

      #modalContenido::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: padding-box;
      }

      #modalContenido::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
        background-clip: padding-box;
      }

      #modalContenido h2 {
        color: rgba(255, 255, 255, 0.95);
        margin-top: 0;
        font-size: 16px;
        font-weight: 600;
        letter-spacing: -0.2px;
      }

      #modalContenido strong {
        color: rgba(255, 255, 255, 0.9);
        font-weight: 600;
      }

      /* ===== Loader - Frosted Style ===== */
      .loader {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 3px solid rgba(255, 255, 255, 0.15);
        border-top: 3px solid rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        z-index: 100;
        display: none;
      }

      .loader.active {
        display: block;
      }

      /* ===== Efectos adicionales ===== */
      .fade-in {
        animation: fadeIn 0.5s ease-out;
      }

      .scale-in {
        animation: scaleIn 0.5s ease-out;
      }

      .slide-in {
        animation: slideIn 0.5s ease-out;
      }

      /* Sliders - Frosted macOS Style */
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 4px;
        background: rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        outline: none;
        position: relative;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.1);
        border: 0.5px solid rgba(255, 255, 255, 0.2);
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.15);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.15);
      }

      input[type="range"]::-webkit-slider-thumb:active {
        transform: scale(1.05);
      }

      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 50%;
        cursor: pointer;
        border: 0.5px solid rgba(255, 255, 255, 0.2);
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      input[type="range"]::-moz-range-thumb:hover {
        transform: scale(1.15);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.15);
      }

      input[type="range"]::-moz-range-thumb:active {
        transform: scale(1.05);
      }

      /* ===== BOTONES - Frosted macOS Style ===== */
      .btn-action {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        width: 100%;
        padding: 10px 16px;
        margin: 6px 0;
        border: 0.5px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        text-align: center;
        backdrop-filter: blur(10px);
      }

      .btn-action:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .btn-action:active {
        transform: translateY(0);
        opacity: 0.8;
      }

      .btn-export {
        background: rgba(52, 211, 153, 0.12);
        border-color: rgba(52, 211, 153, 0.2);
        color: rgba(167, 243, 208, 0.95);
      }

      .btn-export:hover {
        background: rgba(52, 211, 153, 0.18);
        border-color: rgba(52, 211, 153, 0.3);
      }

      .btn-import {
        background: rgba(139, 92, 246, 0.12);
        border-color: rgba(139, 92, 246, 0.2);
        color: rgba(196, 181, 253, 0.95);
      }

      .btn-import:hover {
        background: rgba(139, 92, 246, 0.18);
        border-color: rgba(139, 92, 246, 0.3);
      }

      /* Divider - Frosted Style */
      .divider {
        height: 0.5px;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
        margin: 16px 0;
      }

      /* ===== NOTIFICACIONES TOAST - Frosted Style ===== */
      .toast-container {
        position: fixed;
        top: 24px;
        right: 24px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
      }

      .toast {
        min-width: 280px;
        max-width: 400px;
        padding: 14px 18px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(40px) saturate(180%);
        -webkit-backdrop-filter: blur(40px) saturate(180%);
        border: 0.5px solid rgba(255, 255, 255, 0.18);
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.12),
          0 2px 8px rgba(0, 0, 0, 0.08),
          inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.95);
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 12px;
        pointer-events: auto;
        animation: toastSlideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }

      .toast.closing {
        animation: toastSlideOut 0.25s ease-out forwards;
      }

      .toast-icon {
        font-size: 18px;
        line-height: 1;
        flex-shrink: 0;
        opacity: 0.9;
      }

      .toast-message {
        flex: 1;
        line-height: 1.4;
      }

      .toast-success {
        border-left: 2px solid rgba(52, 211, 153, 0.6);
      }

      .toast-error {
        border-left: 2px solid rgba(248, 113, 113, 0.6);
      }

      .toast-info {
        border-left: 2px solid rgba(96, 165, 250, 0.6);
      }

      .toast-warning {
        border-left: 2px solid rgba(251, 191, 36, 0.6);
      }

      @keyframes toastSlideIn {
        from {
          transform: translateX(100px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes toastSlideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100px);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loader -->
    <div class="loader active" id="loader"></div>

    <!-- Contenedor de Notificaciones Toast -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Input file oculto para importar -->
    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <!-- Panel de control -->
    <div id="controles">
      <!-- Header del Dashboard -->
      <div class="dashboard-header">
        <h1 class="dashboard-title">
          <span>‚óÜ</span>
          <span>Memento</span>
        </h1>
        <p class="dashboard-subtitle">Control Panel</p>
      </div>

      <!-- Contenido con scroll -->
      <div class="dashboard-content">
        
        <!-- Secci√≥n: Visualizaci√≥n -->
        <div class="control-section">
          <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
              <span class="section-icon">‚óã</span>
              <span>Visualizaci√≥n</span>
            </div>
            <span class="section-toggle">‚ñº</span>
          </div>
          <div class="section-content">
            <div class="control-group">
              <div class="control-label">
                <span>Grosor m√≠nimo</span>
                <span id="grosorMinValor" class="control-value">1</span>
              </div>
              <input id="grosorMin" type="range" min="1" max="10" value="1">
            </div>

            <div class="control-group">
              <div class="control-label">
                <span>Grosor m√°ximo</span>
                <span id="grosorMaxValor" class="control-value">6</span>
              </div>
              <input id="grosorMax" type="range" min="1" max="20" value="6">
            </div>

            <div class="control-group">
              <div class="control-label">
                <span>Transparencia c√°psulas</span>
                <span id="opacidadCapsulasValor" class="control-value">25%</span>
              </div>
              <input id="opacidadCapsulas" type="range" min="5" max="100" value="25">
            </div>
          </div>
        </div>

        <!-- Secci√≥n: Conexiones -->
        <div class="control-section">
          <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
              <span class="section-icon">‚óá</span>
              <span>Conexiones</span>
            </div>
            <span class="section-toggle">‚ñº</span>
          </div>
          <div class="section-content">
            <div class="control-group">
              <div class="control-label">
                <span>M√°x. conexiones</span>
                <span id="maxConexionesValor" class="control-value">2</span>
              </div>
              <input id="maxConexiones" type="range" min="1" max="6" value="2">
            </div>

            <div class="checkbox-group">
              <input id="chkMostrarLineas" type="checkbox" checked>
              <label for="chkMostrarLineas">Mostrar conexiones</label>
            </div>

            <div class="checkbox-group">
              <input id="chkMostrarCapsulas" type="checkbox" checked>
              <label for="chkMostrarCapsulas">Mostrar c√°psulas</label>
            </div>
          </div>
        </div>

        <!-- Secci√≥n: Propiedades -->
        <div class="control-section">
          <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
              <span class="section-icon">‚óê</span>
              <span>Propiedades</span>
            </div>
            <span class="section-toggle">‚ñº</span>
          </div>
          <div class="section-content">
            <div id="propiedades"></div>
          </div>
        </div>

        <!-- Secci√≥n: Navegaci√≥n -->
        <div class="control-section">
          <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
              <span class="section-icon">‚óé</span>
              <span>Controles</span>
            </div>
            <span class="section-toggle">‚ñº</span>
          </div>
          <div class="section-content">
            <div id="ayudaTeclas">
              <strong>Teclado</strong>
              W / A / S / D ‚Äî Movimiento<br>
              Q / E ‚Äî Subir / Bajar<br>
              <strong>Rat√≥n</strong>
              Arrastrar ‚Äî Mirar alrededor<br>
              Clic ‚Äî Ver detalles
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <!-- Secci√≥n: Gesti√≥n de Datos -->
        <div class="control-section">
          <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
              <span class="section-icon">‚óà</span>
              <span>Datos</span>
            </div>
            <span class="section-toggle">‚ñº</span>
          </div>
          <div class="section-content">
            <button class="btn-action btn-export" id="btnExportJSON">
              <span>‚Üì</span>
              <span>Exportar JSON</span>
            </button>
            <button class="btn-action btn-export" id="btnExportCSV">
              <span>‚Üì</span>
              <span>Exportar CSV</span>
            </button>
            <button class="btn-action btn-import" id="btnImportJSON">
              <span>‚Üë</span>
              <span>Importar JSON</span>
            </button>
          </div>
        </div>

      </div>
    </div>

    <!-- Modal 2D -->
    <div id="modalOverlay">
      <div id="modalCaja">
        <div id="modalHeader">
          <div id="modalTitulo">Detalle de nodo</div>
          <button id="modalCerrar">‚úï Cerrar</button>
        </div>
        <div id="modalContenido"></div>
      </div>
    </div>

    <!-- Escena A-Frame -->
    <a-scene background="color: #000000">
      <!-- Cielo con gradiente -->
      <a-sky material="shader: gradiente; topColor: #88c8ff; bottomColor: #02041a"></a-sky>

      <!-- C√°mara con look-controls + cursor/mouse + raycaster -->
      <a-entity id="rig"
                camera
                look-controls
                position="0 3 15"
                cursor="rayOrigin: mouse; fuse: false"
                raycaster="objects: .clickable; far: 100">
      </a-entity>

      <!-- üí° SISTEMA DE ILUMINACI√ìN DIN√ÅMICA (5 luces animadas) -->
      
      <!-- üåü Luz Ambiental Base - Azul suave del cielo con pulsaci√≥n lenta -->
      <a-entity light="type: ambient; color: #88c8ff; intensity: 0.4"
                animation="property: light.intensity; from: 0.3; to: 0.5; dur: 4000; dir: alternate; loop: true; easing: easeInOutSine">
      </a-entity>
      
      <!-- ‚úÖ Luz Success (Verde) - Energizante, arriba-derecha, pulsaci√≥n r√°pida -->
      <a-entity light="type: point; color: #34D399; intensity: 0.6; distance: 30; decay: 2" 
                position="5 6 3"
                animation="property: light.intensity; from: 0.4; to: 0.8; dur: 2500; dir: alternate; loop: true; easing: easeInOutQuad">
      </a-entity>
      
      <!-- ‚ö†Ô∏è Luz Warning (Amarilla) - C√°lida, izquierda-frontal, pulsaci√≥n media -->
      <a-entity light="type: point; color: #FBBF24; intensity: 0.5; distance: 25; decay: 2" 
                position="-6 5 5"
                animation="property: light.intensity; from: 0.3; to: 0.6; dur: 3200; dir: alternate; loop: true; easing: easeInOutSine">
      </a-entity>
      
      <!-- ‚ÑπÔ∏è Luz Info (Azul) - Principal focal, centro-atr√°s, respiraci√≥n lenta -->
      <a-entity light="type: point; color: #60A5FA; intensity: 0.7; distance: 35; decay: 2" 
                position="0 7 -8"
                animation="property: light.intensity; from: 0.5; to: 0.9; dur: 3800; dir: alternate; loop: true; easing: easeInOutCubic">
      </a-entity>
      
      <!-- üî• Luz Accent (Rojo) - Contraste sutil, derecha-atr√°s, latido r√°pido -->
      <a-entity light="type: point; color: #F87171; intensity: 0.3; distance: 20; decay: 2" 
                position="7 4 -5"
                animation="property: light.intensity; from: 0.15; to: 0.45; dur: 2000; dir: alternate; loop: true; easing: easeInOutQuad">
      </a-entity>

      <!-- Contenedor de conexiones -->
      <a-entity id="conexiones"></a-entity>

      <!-- Contenedor de nodos -->
      <a-entity id="nodos"></a-entity>
    </a-scene>

    <script>
      const THREE = AFRAME.THREE;

      // ===== FUNCI√ìN PARA SECCIONES COLAPSABLES =====
      function toggleSection(headerElement) {
        const section = headerElement.parentElement;
        section.classList.toggle('collapsed');
      }

      // ===== SISTEMA DE NOTIFICACIONES TOAST =====
      const toastContainer = document.getElementById('toastContainer');

      function mostrarToast(mensaje, tipo = 'info', duracion = 3000) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${tipo}`;
        
        const iconos = {
          success: '‚úÖ',
          error: '‚ùå',
          info: '‚ÑπÔ∏è',
          warning: '‚ö†Ô∏è'
        };
        
        toast.innerHTML = `
          <span class="toast-icon">${iconos[tipo] || '‚ÑπÔ∏è'}</span>
          <span class="toast-message">${mensaje}</span>
        `;
        
        toastContainer.appendChild(toast);
        
        // Auto-eliminar despu√©s de la duraci√≥n
        setTimeout(() => {
          toast.classList.add('closing');
          setTimeout(() => {
            if (toast.parentElement) {
              toast.parentElement.removeChild(toast);
            }
          }, 300);
        }, duracion);
        
        // Click para cerrar manualmente
        toast.addEventListener('click', () => {
          toast.classList.add('closing');
          setTimeout(() => {
            if (toast.parentElement) {
              toast.parentElement.removeChild(toast);
            }
          }, 300);
        });
      }

      // ===== FUNCIONES DE EXPORTACI√ìN =====
      function descargarArchivo(contenido, nombreArchivo, tipoMIME) {
        const blob = new Blob([contenido], { type: tipoMIME });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = nombreArchivo;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function exportarJSON() {
        try {
          if (!datosOriginales || datosOriginales.length === 0) {
            mostrarToast('No hay datos para exportar', 'warning');
            return;
          }
          
          const jsonString = JSON.stringify(datosOriginales, null, 2);
          const fecha = new Date().toISOString().split('T')[0];
          const nombreArchivo = `memento-export-${fecha}.json`;
          
          descargarArchivo(jsonString, nombreArchivo, 'application/json');
          mostrarToast(`‚ú® Exportados ${datosOriginales.length} registros a JSON`, 'success');
        } catch (error) {
          console.error('Error al exportar JSON:', error);
          mostrarToast('Error al exportar JSON: ' + error.message, 'error');
        }
      }

      function exportarCSV() {
        try {
          if (!datosOriginales || datosOriginales.length === 0) {
            mostrarToast('No hay datos para exportar', 'warning');
            return;
          }
          
          // Obtener todas las propiedades √∫nicas
          const propiedades = new Set();
          datosOriginales.forEach(item => {
            if (item.categories) {
              Object.keys(item.categories).forEach(key => propiedades.add(key));
            }
          });
          
          const columnas = Array.from(propiedades).sort();
          
          // Crear encabezados CSV
          let csv = columnas.map(col => `"${col}"`).join(',') + '\n';
          
          // Agregar cada fila de datos
          datosOriginales.forEach(item => {
            const fila = columnas.map(col => {
              const valor = item.categories && item.categories[col] ? item.categories[col] : '';
              // Escapar comillas dobles y envolver en comillas
              return `"${String(valor).replace(/"/g, '""')}"`;
            });
            csv += fila.join(',') + '\n';
          });
          
          const fecha = new Date().toISOString().split('T')[0];
          const nombreArchivo = `memento-export-${fecha}.csv`;
          
          // UTF-8 BOM para compatibilidad con Excel
          const bom = '\uFEFF';
          descargarArchivo(bom + csv, nombreArchivo, 'text/csv;charset=utf-8;');
          mostrarToast(`üìä Exportados ${datosOriginales.length} registros a CSV`, 'success');
        } catch (error) {
          console.error('Error al exportar CSV:', error);
          mostrarToast('Error al exportar CSV: ' + error.message, 'error');
        }
      }

      // ===== FUNCIONES DE IMPORTACI√ìN =====
      function validarDatosJSON(datos) {
        if (!Array.isArray(datos)) {
          throw new Error('El archivo debe contener un array de objetos');
        }
        
        if (datos.length === 0) {
          throw new Error('El archivo est√° vac√≠o');
        }
        
        // Validar estructura de cada elemento
        let validos = 0;
        datos.forEach((item, index) => {
          if (typeof item !== 'object' || item === null) {
            throw new Error(`Elemento ${index + 1} no es un objeto v√°lido`);
          }
          
          // Verificar que tenga al menos categories
          if (!item.categories || typeof item.categories !== 'object') {
            console.warn(`Elemento ${index + 1} no tiene categories v√°lido, se ignorar√°`);
          } else {
            validos++;
          }
        });
        
        if (validos === 0) {
          throw new Error('Ning√∫n elemento tiene una estructura v√°lida (necesita "categories")');
        }
        
        return validos;
      }

      function importarJSON() {
        const fileInput = document.getElementById('fileInput');
        
        fileInput.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          mostrarToast('‚è≥ Cargando archivo...', 'info', 2000);
          
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const contenido = event.target.result;
              const datos = JSON.parse(contenido);
              
              // Validar datos
              const validos = validarDatosJSON(datos);
              
              // Filtrar solo elementos v√°lidos
              const datosValidos = datos.filter(item => 
                item.categories && typeof item.categories === 'object'
              );
              
              // Recargar la escena con los nuevos datos
              recargarEscenaConDatos(datosValidos);
              
              mostrarToast(
                `‚úÖ Importados ${validos} registros correctamente`, 
                'success', 
                4000
              );
              
            } catch (error) {
              console.error('Error al importar:', error);
              mostrarToast(
                `‚ùå Error al importar: ${error.message}`, 
                'error', 
                5000
              );
            }
          };
          
          reader.onerror = () => {
            mostrarToast('Error al leer el archivo', 'error');
          };
          
          reader.readAsText(file);
          
          // Limpiar input para permitir seleccionar el mismo archivo de nuevo
          fileInput.value = '';
        };
        
        fileInput.click();
      }

      function recargarEscenaConDatos(nuevosItems) {
        // Limpiar escena actual
        while (nodosContEl.firstChild) {
          nodosContEl.removeChild(nodosContEl.firstChild);
        }
        while (conexionesEl.firstChild) {
          conexionesEl.removeChild(conexionesEl.firstChild);
        }
        
        // Reiniciar estado
        particulas = [];
        conexionesActivadas = false;
        etiquetasSucias = false;
        contadorFrames = 0;
        ultimoTiempo = null;
        
        // Actualizar datos originales
        datosOriginales = nuevosItems;
        
        // Detectar claves de propiedades
        const setClaves = new Set();
        nuevosItems.forEach(item => {
          const cats = item.categories || {};
          Object.keys(cats).forEach(k => setClaves.add(k));
        });
        const claves = Array.from(setClaves);
        
        // Recrear controles y nodos
        crearControlesPropiedades(claves);
        crearNodos3D(nuevosItems);
        
        // Reactivar animaciones y conexiones
        const tiempoAnimacionTotal = (nuevosItems.length * 30) + 800 + 200;
        setTimeout(() => {
          conexionesActivadas = true;
          actualizarConexiones();
        }, tiempoAnimacionTotal);
        
        mostrarToast('üîÑ Escena recargada con nuevos datos', 'info', 3000);
      }

      // ---------- Shader gradiente para el cielo ----------
      AFRAME.registerShader('gradiente', {
        schema: {
          topColor:    {type: 'color', default: '#88c8ff'},
          bottomColor: {type: 'color', default: '#02041a'}
        },
        init: function (data) {
          this.uniforms = {
            topColor:    { value: new THREE.Color(data.topColor) },
            bottomColor: { value: new THREE.Color(data.bottomColor) }
          };
          this.material = new THREE.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: `
              varying vec3 vWorldPosition;
              void main() {
                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
              }
            `,
            fragmentShader: `
              uniform vec3 topColor;
              uniform vec3 bottomColor;
              varying vec3 vWorldPosition;
              void main() {
                float h = normalize(vWorldPosition).y;
                float t = clamp(h * 0.5 + 0.5, 0.0, 1.0);
                vec3 color = mix(bottomColor, topColor, t);
                gl_FragColor = vec4(color, 1.0);
              }
            `,
            side: THREE.BackSide,
            depthWrite: false
          });
        },
        update: function (data) {
          this.uniforms.topColor.value.set(data.topColor);
          this.uniforms.bottomColor.value.set(data.bottomColor);
        }
      });

      // ---------- Componente billboard ----------
      AFRAME.registerComponent('billboard', {
        schema: { target: { type: 'selector' } },
        init: function () {
          this.camEl = this.data.target || document.querySelector('#rig');
        },
        tick: function () {
          if (!this.camEl) return;
          const obj = this.el.object3D;
          const camPos = new THREE.Vector3();
          this.camEl.object3D.getWorldPosition(camPos);
          obj.lookAt(camPos);
        }
      });

      // ---------- Componente c√°psula transparente ----------
      AFRAME.registerComponent('transparente-capsula', {
        schema: {
          opacity: { type: 'number', default: 0.25 }
        },
        init: function () {
          const el = this.el;
          const self = this;

          this.applySettings = function () {
            el.object3D.traverse(obj => {
              if (obj.isMesh && obj.material) {
                const m = obj.material;
                m.transparent = true;
                m.opacity = self.data.opacity;
                m.depthWrite = false;
                m.depthTest  = true;
                m.side = THREE.DoubleSide;
                m.needsUpdate = true;
              }
            });
          };

          if (el.object3D) {
            this.applySettings();
          }
          el.addEventListener('object3dset', () => this.applySettings());
        },
        update: function (oldData) {
          if (oldData && oldData.opacity === this.data.opacity) return;
          if (this.applySettings) this.applySettings();
        }
      });

      // ---------- Componente de animaci√≥n de entrada para nodos ----------
      AFRAME.registerComponent('nodo-animado', {
        schema: {
          delay: { type: 'number', default: 0 }
        },
        init: function () {
          const el = this.el;
          const delay = this.data.delay;
          
          // Iniciar invisible y peque√±o
          el.object3D.scale.set(0.01, 0.01, 0.01);
          el.object3D.visible = false;
          
          // Animar despu√©s del delay
          setTimeout(() => {
            el.object3D.visible = true;
            const startScale = 0.01;
            const endScale = 1;
            const duration = 800; // ms
            const startTime = Date.now();
            
            const animate = () => {
              const elapsed = Date.now() - startTime;
              const progress = Math.min(elapsed / duration, 1);
              
              // Easing cubic out
              const eased = 1 - Math.pow(1 - progress, 3);
              const currentScale = startScale + (endScale - startScale) * eased;
              
              el.object3D.scale.set(currentScale, currentScale, currentScale);
              
              if (progress < 1) {
                requestAnimationFrame(animate);
              }
            };
            
            animate();
          }, delay);
        }
      });

      // ---------- Utilidades ----------
      function distancia3D(x1,y1,z1,x2,y2,z2){
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dz = z2 - z1;
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
      }

      function hashCadena(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = (hash * 31 + str.charCodeAt(i)) | 0;
        }
        return Math.abs(hash);
      }

      const nodosContEl   = document.getElementById("nodos");
      const conexionesEl  = document.getElementById("conexiones");
      const rigEl         = document.getElementById("rig");
      const loaderEl      = document.getElementById("loader");

      // Modal
      const modalOverlay   = document.getElementById("modalOverlay");
      const modalContenido = document.getElementById("modalContenido");
      const modalTitulo    = document.getElementById("modalTitulo");
      const modalCerrar    = document.getElementById("modalCerrar");

      function mostrarModal(titulo, html){
        modalTitulo.textContent = titulo || "Detalle de nodo";
        modalContenido.innerHTML = html || "<p>(Sin contenido)</p>";
        modalOverlay.style.display = "flex";
      }
      function ocultarModal(){
        modalOverlay.style.display = "none";
      }
      modalCerrar.addEventListener("click", ocultarModal);
      modalOverlay.addEventListener("click", (e)=>{
        if (e.target === modalOverlay) ocultarModal();
      });

      // ---------- Par√°metros espaciales y f√≠sicos ----------
      const LIM_X = 20;
      const LIM_Y = 10;
      const LIM_Z = 20;

      const DISTANCIA_OBJETIVO           = 6;
      const DISTANCIA_MINIMA             = 1.8;
      const DISTANCIA_REPULSION_DISTINTO = 14;

      const K_ATRACCION_FUERTE   = 0.0015;
      const K_ATRACCION_MEDIA    = 0.0009;
      const K_REPULSION_DISTINTO = 0.001;
      const K_REPULSION_CORTA    = 0.06;

      const FRICCION   = 0.93;
      const MAX_FUERZA = 0.05;

      const RADIO_CONEXION         = 12;
      const ACTUALIZAR_LINEAS_CADA = 10;

      // ---------- Controles UI ----------
      let grosorMin = 1;
      let grosorMax = 6;
      let mostrarLineas = true;

      let clavesPropiedades = [];
      let usarEnRelacion    = {};
      let mostrarEnEtiqueta = {};

      let mostrarCapsulas   = true;
      let opacidadCapsulas  = 0.25;

      let maxConexionesPorNodo = 2;
      
      // Variable global para almacenar datos originales
      let datosOriginales = [];

      const sliderMin = document.getElementById("grosorMin");
      const sliderMax = document.getElementById("grosorMax");
      const spanMin   = document.getElementById("grosorMinValor");
      const spanMax   = document.getElementById("grosorMaxValor");
      const chkMostrarLineas = document.getElementById("chkMostrarLineas");
      const divPropiedades   = document.getElementById("propiedades");

      const chkMostrarCapsulas       = document.getElementById("chkMostrarCapsulas");
      const sliderOpacidadCapsulas   = document.getElementById("opacidadCapsulas");
      const spanOpacidadCapsulas     = document.getElementById("opacidadCapsulasValor");

      const sliderMaxConexiones      = document.getElementById("maxConexiones");
      const spanMaxConexiones        = document.getElementById("maxConexionesValor");

      sliderMin.addEventListener("input", () => {
        grosorMin = parseFloat(sliderMin.value);
        spanMin.textContent = sliderMin.value;
        if (grosorMin > grosorMax) {
          grosorMax = grosorMin;
          sliderMax.value = grosorMax;
          spanMax.textContent = grosorMax;
        }
      });

      sliderMax.addEventListener("input", () => {
        grosorMax = parseFloat(sliderMax.value);
        spanMax.textContent = sliderMax.value;
        if (grosorMax < grosorMin) {
          grosorMin = grosorMax;
          sliderMin.value = grosorMin;
          spanMin.textContent = grosorMin;
        }
      });

      sliderMaxConexiones.addEventListener("input", () => {
        maxConexionesPorNodo = parseInt(sliderMaxConexiones.value, 10);
        spanMaxConexiones.textContent = sliderMaxConexiones.value;
        if (conexionesActivadas) {
          actualizarConexiones(); // Actualizar inmediatamente cuando se cambia el valor
        }
      });

      chkMostrarLineas.addEventListener("change", () => {
        mostrarLineas = chkMostrarLineas.checked;
        if (conexionesActivadas) {
          actualizarConexiones(); // Actualizar inmediatamente cuando se cambia el checkbox
        }
      });

      chkMostrarCapsulas.addEventListener("change", () => {
        mostrarCapsulas = chkMostrarCapsulas.checked;
        particulas.forEach(p => {
          if (p.capsulaEl) {
            p.capsulaEl.object3D.visible = mostrarCapsulas;
          }
        });
      });

      sliderOpacidadCapsulas.addEventListener("input", () => {
        const v = parseInt(sliderOpacidadCapsulas.value, 10);
        opacidadCapsulas = v / 100;
        spanOpacidadCapsulas.textContent = v + "%";
        particulas.forEach(p => {
          if (p.capsulaEl) {
            p.capsulaEl.setAttribute("transparente-capsula", "opacity:" + opacidadCapsulas);
          }
        });
      });

      let etiquetasSucias = false;

      function crearControlesPropiedades(claves){
        divPropiedades.innerHTML = "";
        clavesPropiedades = claves.slice();

        // Actualizar contador en el t√≠tulo de la secci√≥n
        const seccionPropiedades = document.querySelector('.control-section:has(#propiedades)');
        if (seccionPropiedades) {
          const tituloSpan = seccionPropiedades.querySelector('.section-title span:last-child');
          if (tituloSpan) {
            let contadorBadge = tituloSpan.querySelector('.prop-counter');
            if (claves.length > 0) {
              if (!contadorBadge) {
                contadorBadge = document.createElement('span');
                contadorBadge.className = 'prop-counter';
                tituloSpan.appendChild(contadorBadge);
              }
              contadorBadge.textContent = claves.length;
            } else if (contadorBadge) {
              contadorBadge.remove();
            }
          }
        }

        if (claves.length === 0) {
          // Mostrar mensaje cuando no hay propiedades
          const mensaje = document.createElement('div');
          mensaje.style.cssText = `
            padding: 30px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            font-style: italic;
          `;
          mensaje.textContent = 'No hay propiedades detectadas';
          divPropiedades.appendChild(mensaje);
          etiquetasSucias = true;
          return;
        }

        clavesPropiedades.forEach((prop, index) => {
          if (!(prop in usarEnRelacion))    usarEnRelacion[prop] = true;
          if (!(prop in mostrarEnEtiqueta)) mostrarEnEtiqueta[prop] = true;

          const bloque = document.createElement("div");
          bloque.className = "bloque-prop";
          bloque.style.animationDelay = (index * 0.05) + 's';

          const titulo = document.createElement("div");
          titulo.className = "titulo-prop";
          titulo.textContent = prop;
          bloque.appendChild(titulo);

          const lblUsar = document.createElement("label");
          const chkUsar = document.createElement("input");
          chkUsar.type = "checkbox";
          chkUsar.checked = usarEnRelacion[prop];
          chkUsar.addEventListener("change", () => {
            usarEnRelacion[prop] = chkUsar.checked;
            particulas.forEach(p => {
              p.fija = false;
              p.estableFrames = 0;
            });
          });
          lblUsar.appendChild(chkUsar);
          lblUsar.appendChild(document.createTextNode(" Usar en relaci√≥n"));
          bloque.appendChild(lblUsar);

          const lblMostrar = document.createElement("label");
          const chkMostrar = document.createElement("input");
          chkMostrar.type = "checkbox";
          chkMostrar.checked = mostrarEnEtiqueta[prop];
          chkMostrar.addEventListener("change", () => {
            mostrarEnEtiqueta[prop] = chkMostrar.checked;
            etiquetasSucias = true;
          });
          lblMostrar.appendChild(chkMostrar);
          lblMostrar.appendChild(document.createTextNode(" Mostrar en etiqueta"));
          bloque.appendChild(lblMostrar);

          divPropiedades.appendChild(bloque);
        });

        etiquetasSucias = true;
      }

      // ---------- Datos y nodos ----------
      let particulas = [];
      let numeroParticulas = 0;

      function construirEtiqueta(datosCategorias){
        const lineas = [];
        for (const prop of clavesPropiedades){
          if (!mostrarEnEtiqueta[prop]) continue;
          const val = (datosCategorias[prop] !== undefined && datosCategorias[prop] !== null)
                      ? String(datosCategorias[prop])
                      : "";
          lineas.push(val);
        }
        return lineas.join("\n");
      }

      // C√°psula transparente horizontal:
      // ahora se marcan como .clickable las entidades con geometr√≠a
      function crearCapsulaTransparenteHorizontal(){
        const capsula = document.createElement("a-entity");
        capsula.setAttribute("rotation", "0 0 90");
        capsula.setAttribute("transparente-capsula", "opacity:0.25");

        const cilindro = document.createElement("a-cylinder");
        cilindro.setAttribute("radius", 0.7);
        cilindro.setAttribute("height", 1.8);
        cilindro.setAttribute("position", "0 0 0");
        cilindro.setAttribute("class", "clickable");
        capsula.appendChild(cilindro);

        const esferaArriba = document.createElement("a-sphere");
        esferaArriba.setAttribute("radius", 0.7);
        esferaArriba.setAttribute("position", "0 0.9 0");
        esferaArriba.setAttribute("class", "clickable");
        capsula.appendChild(esferaArriba);

        const esferaAbajo = document.createElement("a-sphere");
        esferaAbajo.setAttribute("radius", 0.7);
        esferaAbajo.setAttribute("position", "0 -0.9 0");
        esferaAbajo.setAttribute("class", "clickable");
        capsula.appendChild(esferaAbajo);

        return capsula;
      }

      function crearNodos3D(items){
        particulas = [];
        numeroParticulas = items.length;

        for (let i = 0; i < items.length; i++){
          const item = items[i];
          const categorias    = item.categories || {};
          const contenidoHtml = item.content    || "";

          const x = (Math.random() - 0.5) * LIM_X * 2;
          const y = Math.random() * LIM_Y + 1;
          const z = (Math.random() - 0.5) * LIM_Z * 2;

          const nodo = document.createElement("a-entity");
          nodo.setAttribute("position", `${x} ${y} ${z}`);
          nodo.setAttribute("billboard", "target: #rig");
          
          // A√±adir animaci√≥n de entrada con delay escalonado
          nodo.setAttribute("nodo-animado", `delay: ${i * 30}`);

          const capsula = crearCapsulaTransparenteHorizontal();
          nodo.appendChild(capsula);

          const texto = document.createElement("a-entity");
          texto.setAttribute("text", {
            value: construirEtiqueta(categorias),
            align: "center",
            color: "#ffffff",
            width: 3,
            wrapCount: 20,
            baseline: "center"
          });
          texto.setAttribute("position", "0 0 -1.0");
          texto.setAttribute("class", "clickable"); // tambi√©n clickable el texto
          nodo.appendChild(texto);

          nodosContEl.appendChild(nodo);

          const pObj = {
            x:x, y:y, z:z,
            vx:(Math.random()-0.5)*0.1,
            vy:(Math.random()-0.5)*0.1,
            vz:(Math.random()-0.5)*0.1,
            ax:0, ay:0, az:0,
            fija:false,
            estableFrames:0,
            datos:categorias,
            contenido:contenidoHtml,
            nodeEl:nodo,
            textEl:texto,
            capsulaEl:capsula
          };

          capsula.object3D.visible = mostrarCapsulas;
          capsula.setAttribute("transparente-capsula", "opacity:" + opacidadCapsulas);

          // click en el nodo completo (evento burbujea desde los hijos .clickable)
          nodo.addEventListener("click", () => {
            zoomACentroDeParticula(pObj);
            const tituloModal = categorias.nombre || "Detalle de nodo";
            mostrarModal(tituloModal, contenidoHtml);
          });

          particulas.push(pObj);
        }
      }

      // ---------- F√≠sica 3D ----------
      function pasoFisica(dt){
        const n = numeroParticulas;
        if (n === 0) return;

        for (let i = 0; i < n; i++){
          particulas[i].ax = 0;
          particulas[i].ay = 0;
          particulas[i].az = 0;
        }

        for (let i = 0; i < n; i++){
          const p = particulas[i];
          if (p.fija) continue;

          let fx = 0, fy = 0, fz = 0;

          for (let j = 0; j < n; j++){
            if (i === j) continue;
            const q = particulas[j];

            const d = distancia3D(p.x,p.y,p.z, q.x,q.y,q.z);
            if (d === 0) continue;

            const dx = q.x - p.x;
            const dy = q.y - p.y;
            const dz = q.z - p.z;

            const ux = dx / d;
            const uy = dy / d;
            const uz = dz / d;

            if (d < DISTANCIA_MINIMA){
              const intensidad = (DISTANCIA_MINIMA - d) * K_REPULSION_CORTA;
              fx -= ux * intensidad;
              fy -= uy * intensidad;
              fz -= uz * intensidad;
              continue;
            }

            const propsCoinciden = [];
            let hayPropsRelacionActivas = false;
            for (const prop of clavesPropiedades){
              if (!usarEnRelacion[prop]) continue;
              hayPropsRelacionActivas = true;
              if (p.datos[prop] === q.datos[prop]){
                propsCoinciden.push(prop);
              }
            }

            if (propsCoinciden.length > 1){
              const delta = d - DISTANCIA_OBJETIVO;
              fx += ux * delta * K_ATRACCION_FUERTE;
              fy += uy * delta * K_ATRACCION_FUERTE;
              fz += uz * delta * K_ATRACCION_FUERTE;
            } else if (propsCoinciden.length === 1){
              const delta = d - DISTANCIA_OBJETIVO;
              fx += ux * delta * K_ATRACCION_MEDIA;
              fy += uy * delta * K_ATRACCION_MEDIA;
              fz += uz * delta * K_ATRACCION_MEDIA;
            } else {
              if (d < DISTANCIA_REPULSION_DISTINTO){
                const intensidad = (DISTANCIA_REPULSION_DISTINTO - d) * K_REPULSION_DISTINTO;
                fx -= ux * intensidad;
                fy -= uy * intensidad;
                fz -= uz * intensidad;
              }
            }
          }

          const modF = Math.sqrt(fx*fx + fy*fy + fz*fz);
          if (modF > MAX_FUERZA){
            fx = fx / modF * MAX_FUERZA;
            fy = fy / modF * MAX_FUERZA;
            fz = fz / modF * MAX_FUERZA;
          }

          p.ax = fx;
          p.ay = fy;
          p.az = fz;
        }

        for (let i = 0; i < n; i++){
          const p = particulas[i];
          if (!p.fija){
            p.vx += p.ax;
            p.vy += p.ay;
            p.vz += p.az;

            p.vx *= FRICCION;
            p.vy *= FRICCION;
            p.vz *= FRICCION;

            p.x += p.vx;
            p.y += p.vy;
            p.z += p.vz;

            const REBOTE = -0.5;
            if (p.x > LIM_X){ p.x = LIM_X; p.vx *= REBOTE; }
            if (p.x < -LIM_X){ p.x = -LIM_X; p.vx *= REBOTE; }
            if (p.z > LIM_Z){ p.z = LIM_Z; p.vz *= REBOTE; }
            if (p.z < -LIM_Z){ p.z = -LIM_Z; p.vz *= REBOTE; }
            if (p.y > LIM_Y){ p.y = LIM_Y; p.vy *= REBOTE; }
            if (p.y < 0.5){ p.y = 0.5; p.vy *= REBOTE; }

            const vel  = Math.sqrt(p.vx*p.vx + p.vy*p.vy + p.vz*p.vz);
            const fuer = Math.sqrt(p.ax*p.ax + p.ay*p.ay + p.az*p.az);
            if (vel < 0.02 && fuer < 0.002){
              p.estableFrames++;
              if (p.estableFrames > 60){
                p.fija = true;
                p.vx = p.vy = p.vz = 0;
              }
            } else {
              p.estableFrames = 0;
            }
          }

          p.nodeEl.setAttribute("position", `${p.x} ${p.y} ${p.z}`);

          if (etiquetasSucias){
            p.textEl.setAttribute("text", "value", construirEtiqueta(p.datos));
          }
        }

        if (etiquetasSucias){
          etiquetasSucias = false;
        }
      }

      // ---------- Conexiones 3D ----------
      let conexionesActivadas = false;
      
      function actualizarConexiones(){
        if (!conexionesActivadas) return; // No dibujar hasta que los nodos se hayan animado
        
        conexionesEl.innerHTML = "";
        if (!MostrarLineasGlobal()) return;

        const n = numeroParticulas;
        for (let i = 0; i < n; i++){
          const a = particulas[i];
          const candidatos = [];

          for (let j = i+1; j < n; j++){
            const b = particulas[j];
            const d = distancia3D(a.x,a.y,a.z, b.x,b.y,b.z);
            if (d > RADIO_CONEXION) continue;

            const propsCoinciden = [];
            let hayPropsRelacionActivas = false;
            for (const prop of clavesPropiedades){
              if (!usarEnRelacion[prop]) continue;
              hayPropsRelacionActivas = true;
              if (a.datos[prop] === b.datos[prop]){
                propsCoinciden.push(prop);
              }
            }

            let clave = "ninguna";
            if (propsCoinciden.length === 1){
              clave = propsCoinciden[0];
            } else if (propsCoinciden.length > 1){
              clave = propsCoinciden.slice().sort().join("+");
            } else if (!hayPropsRelacionActivas){
              clave = "sin-prop-relacion";
            }

            const h = hashCadena(clave) % 360;
            const color = `hsl(${h}, 70%, 50%)`;

            candidatos.push({j, d, color});
          }

          candidatos.sort((a,b) => a.d - b.d);
          const limite = Math.min(maxConexionesPorNodo, candidatos.length);
          for (let k = 0; k < limite; k++){
            const c = candidatos[k];
            const b = particulas[c.j];

            const lineaEl = document.createElement("a-entity");
            lineaEl.setAttribute("line", {
              start: `${a.x} ${a.y} ${a.z}`,
              end:   `${b.x} ${b.y} ${b.z}`,
              color: c.color
            });
            conexionesEl.appendChild(lineaEl);
          }
        }
      }

      function MostrarLineasGlobal() {
        return mostrarLineas;
      }

      // ---------- Fly controls ----------
      const flyEstado = {
        adelante:0,
        atras:0,
        izquierda:0,
        derecha:0,
        arriba:0,
        abajo:0
      };
      const VELOCIDAD_FLY = 6;

      window.addEventListener("keydown", (e) => {
        switch(e.key.toLowerCase()){
          case "w": flyEstado.adelante = 1; break;
          case "s": flyEstado.atras    = 1; break;
          case "a": flyEstado.izquierda= 1; break;
          case "d": flyEstado.derecha  = 1; break;
          case "q": flyEstado.arriba   = 1; break;
          case "e": flyEstado.abajo    = 1; break;
        }
      });

      window.addEventListener("keyup", (e) => {
        switch(e.key.toLowerCase()){
          case "w": flyEstado.adelante = 0; break;
          case "s": flyEstado.atras    = 0; break;
          case "a": flyEstado.izquierda= 0; break;
          case "d": flyEstado.derecha  = 0; break;
          case "q": flyEstado.arriba   = 0; break;
          case "e": flyEstado.abajo    = 0; break;
        }
      });

      function actualizarFly(dt){
        const obj = rigEl.object3D;
        const dir = new THREE.Vector3();
        obj.getWorldDirection(dir);
        dir.normalize();

        const up = new THREE.Vector3(0,1,0);
        const right = new THREE.Vector3().crossVectors(dir, up).normalize().negate();

        let move = new THREE.Vector3(0,0,0);

        if (flyEstado.adelante) move.add(dir.clone().multiplyScalar(-1));
        if (flyEstado.atras)    move.add(dir);
        if (flyEstado.derecha)   move.add(right);
        if (flyEstado.izquierda) move.add(right.clone().multiplyScalar(-1));
        if (flyEstado.arriba) move.add(up);
        if (flyEstado.abajo)  move.add(up.clone().multiplyScalar(-1));

        if (move.lengthSq() > 0){
          move.normalize().multiplyScalar(VELOCIDAD_FLY * dt);
          obj.position.add(move);
        }
      }

      // ---------- Zoom suave ----------
      let zoomAnim = null;

      function zoomACentroDeParticula(p){
        const rigPos = rigEl.object3D.position.clone();
        const destino = new THREE.Vector3(p.x, p.y + 0.5, p.z + 5);
        zoomAnim = { from: rigPos, to: destino, t: 0, dur: 1.0 };
      }

      function actualizarZoom(dt){
        if (!zoomAnim) return;
        zoomAnim.t += dt / zoomAnim.dur;
        let t = zoomAnim.t;
        if (t >= 1) t = 1;
        const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
        const pos = new THREE.Vector3().lerpVectors(zoomAnim.from, zoomAnim.to, ease);
        rigEl.object3D.position.copy(pos);
        if (zoomAnim.t >= 1) zoomAnim = null;
      }

      // ---------- Bucle principal ----------
      let ultimoTiempo = null;
      let contadorFrames = 0;

      function bucle(tiempoMs){
        if (!ultimoTiempo) ultimoTiempo = tiempoMs;
        const dt = (tiempoMs - ultimoTiempo) / 1000;
        ultimoTiempo = tiempoMs;

        pasoFisica(dt);
        actualizarFly(dt);
        actualizarZoom(dt);

        contadorFrames++;
        if (contadorFrames % ACTUALIZAR_LINEAS_CADA === 0){
          actualizarConexiones();
        }

        requestAnimationFrame(bucle);
      }

      // ---------- Event Listeners para Import/Export ----------
      document.getElementById('btnExportJSON').addEventListener('click', exportarJSON);
      document.getElementById('btnExportCSV').addEventListener('click', exportarCSV);
      document.getElementById('btnImportJSON').addEventListener('click', importarJSON);

      // ---------- Carga de datos ----------
      fetch("personas2.json")
        .then(r => r.json())
        .then(items => {
          // Guardar datos originales
          datosOriginales = items;
          const setClaves = new Set();
          items.forEach(item => {
            const cats = item.categories || {};
            Object.keys(cats).forEach(k => setClaves.add(k));
          });
          const claves = Array.from(setClaves);

          crearControlesPropiedades(claves);
          crearNodos3D(items);
          
          // Calcular tiempo total de animaci√≥n de nodos
          // (n√∫mero de nodos * 30ms delay) + 800ms de animaci√≥n + 200ms de margen
          const tiempoAnimacionTotal = (items.length * 30) + 800 + 200;
          
          // Ocultar loader despu√©s de cargar
          setTimeout(() => {
            loaderEl.classList.remove('active');
          }, 1000);
          
          // Activar conexiones despu√©s de que todos los nodos se hayan animado
          setTimeout(() => {
            conexionesActivadas = true;
            actualizarConexiones(); // Dibujar conexiones por primera vez
          }, tiempoAnimacionTotal);
          
          requestAnimationFrame(bucle);
        })
        .catch(err => {
          console.error("Error al cargar personas2.json:", err);
          loaderEl.classList.remove('active');
        });
    </script>
  </body>
</html>
